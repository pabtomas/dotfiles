#! /usr/bin/env dash

alias not='! '

eq () { if [ "${1}" = "${2}" ];   then return 0; else return 1; fi; }
gt () { if [ "${1}" -gt "${2}" ]; then return 0; else return 1; fi; }
lt () { if [ "${1}" -lt "${2}" ]; then return 0; else return 1; fi; }
ge () { if not lt "${1}" "${2}";  then return 0; else return 1; fi; }
le () { if not gt "${1}" "${2}";  then return 0; else return 1; fi; }

is ()
{
  case "${1}" in
  ( dir )      if [ -d "${2}" ]; then return 0; else return 1; fi ;;
  ( nonempty ) if [ -s "${2}" ]; then return 0; else return 1; fi ;;
  ( present )  if [ -e "${2}" ]; then return 0; else return 1; fi ;;
  ( sym )      if [ -L "${2}" ]; then return 0; else return 1; fi ;;
  ( * ) ;;
  esac
}

can ()
{
  case "${1}" in
  ( read )  if [ -r "${2}" ]; then return 0; else return 1; fi ;;
  ( write ) if [ -w "${2}" ]; then return 0; else return 1; fi ;;
  ( exec )  if [ -x "${2}" ]; then return 0; else return 1; fi ;;
  ( * ) ;;
  esac
}

str ()
{
  case "${1}" in
  ( empty ) if [ -z "${2}" ]; then return 0; else return 1; fi ;;
  ( * ) ;;
  esac
}

add_style ()
{
  navy_esc="$(printf '\033')"
  navy_white="${navy_esc}[38;5;15m"
  navy_red="${navy_esc}[38;5;204m"
  navy_yellow="${navy_esc}[38;5;228m"
  navy_green="${navy_esc}[38;5;120m"
  navy_cyan="${navy_esc}[38;5;045m"
  navy_blue="${navy_esc}[38;5;069m"
  navy_purple="${navy_esc}[38;5;135m"
  navy_pink="${navy_esc}[38;5;207m"
  navy_bold="${navy_esc}[1m"
  navy_erase_until_eol="${navy_esc}[K"
  navy_sol="${navy_esc}[G"
  navy_previous="${navy_esc}[F"
  navy_hidecursor="${navy_esc}[?25l"
  navy_showcursor="${navy_esc}[?25h"
  navy_reset="${navy_esc}[m"

  navy_rb196="${navy_esc}[38;5;196m"
  navy_rb202="${navy_esc}[38;5;202m"
  navy_rb208="${navy_esc}[38;5;208m"
  navy_rb214="${navy_esc}[38;5;214m"
  navy_rb220="${navy_esc}[38;5;220m"
  navy_rb226="${navy_esc}[38;5;226m"
  navy_rb190="${navy_esc}[38;5;190m"
  navy_rb154="${navy_esc}[38;5;154m"
  navy_rb118="${navy_esc}[38;5;118m"
  navy_rb82="${navy_esc}[38;5;082m"
  navy_rb46="${navy_esc}[38;5;046m"
  navy_rb47="${navy_esc}[38;5;047m"
  navy_rb48="${navy_esc}[38;5;048m"
  navy_rb49="${navy_esc}[38;5;049m"
  navy_rb50="${navy_esc}[38;5;050m"
  navy_rb51="${navy_esc}[38;5;051m"
  navy_rb45="${navy_esc}[38;5;045m"
  navy_rb39="${navy_esc}[38;5;039m"
  navy_rb33="${navy_esc}[38;5;033m"
  navy_rb27="${navy_esc}[38;5;027m"
  navy_rb21="${navy_esc}[38;5;021m"
  navy_rb57="${navy_esc}[38;5;057m"
  navy_rb93="${navy_esc}[38;5;093m"
  navy_rb128="${navy_esc}[38;5;129m"
  navy_rb165="${navy_esc}[38;5;165m"
  navy_rb201="${navy_esc}[38;5;201m"
  navy_rb200="${navy_esc}[38;5;200m"
  navy_rb199="${navy_esc}[38;5;199m"
  navy_rb198="${navy_esc}[38;5;198m"
  navy_rb197="${navy_esc}[38;5;197m"

  readonly navy_white navy_red navy_yellow navy_green navy_cyan navy_blue navy_purple navy_pink \
           navy_bold \
           navy_erase_until_eol navy_sol navy_previous \
           navy_hidecursor navy_showcursor \
           navy_reset \
           navy_rb196 navy_rb202 navy_rb208 navy_rb214 navy_rb220 navy_rb226 \
           navy_rb190 navy_rb154 navy_rb118 navy_rb82 navy_rb46 navy_rb47 \
           navy_rb48 navy_rb49 navy_rb50 navy_rb51 navy_rb45 navy_rb39 \
           navy_rb33 navy_rb27 navy_rb21 navy_rb57 navy_rb93 navy_rb128 \
           navy_rb165 navy_rb201 navy_rb200 navy_rb199 navy_rb198 navy_rb197
}

add_time ()
{
  navy_s_per_min='60'
  navy_min_per_h='60'
  navy_s_per_h='3600'
  navy_us_per_cs='10000'
  navy_us_per_ds='100000'
  navy_us_per_s='1000000'
  navy_us_per_10s='10000000'
  navy_us_per_min='60000000'
  navy_us_per_10min='600000000'
  navy_us_per_h='3600000000'
  navy_us_per_10h='36000000000'
  navy_us_per_100h='360000000000'

  readonly navy_s_per_min navy_min_per_h navy_s_per_h navy_us_per_cs navy_us_per_ds navy_us_per_s navy_us_per_10s navy_us_per_min navy_us_per_10min navy_us_per_h navy_us_per_10h navy_us_per_100h
}

spins ()
{
  local escape_for_bc_print spin_title_fn

  if not str empty "${1:-}"
  then
    escape_for_bc_print='s@\\@\\\\@g; s@"@\\q@g; s@^\([0-9]\+\)\.\([0-9]\+\) @\1\2print "@; s@$@'"${navy_erase_until_eol}"'\\n";@'
    spin_title_fn='s@$@ define spin_title (index) { } 0@'
    command ts '%.s %T' | command sed -e "${escape_for_bc_print};${spin_title_fn}" -e "${1}" -e "
      s@\(.*\); \(define spin_title (index) {\)@\1\n\2@;
      s@ [0-9]\+\$@;\n@;
      s@^[0-9]\+print \"[0-9][0-9]:[0-9][0-9]:[0-9][0-9] ${navy_rawlevel}@print \"@;
      s@^[0-9]\+@scale = 0\ncnts = \0\n@;
      s@\$@\
define spin_color (index)\n\
{\n\
  if (index ==  0) print \"${navy_rb196}\"\n\
  if (index ==  1) print \"${navy_rb202}\"\n\
  if (index ==  2) print \"${navy_rb208}\"\n\
  if (index ==  3) print \"${navy_rb214}\"\n\
  if (index ==  4) print \"${navy_rb220}\"\n\
  if (index ==  5) print \"${navy_rb226}\"\n\
  if (index ==  6) print \"${navy_rb190}\"\n\
  if (index ==  7) print \"${navy_rb154}\"\n\
  if (index ==  8) print \"${navy_rb118}\"\n\
  if (index ==  9) print \"${navy_rb82}\"\n\
  if (index == 10) print \"${navy_rb46}\"\n\
  if (index == 11) print \"${navy_rb47}\"\n\
  if (index == 12) print \"${navy_rb48}\"\n\
  if (index == 13) print \"${navy_rb49}\"\n\
  if (index == 14) print \"${navy_rb50}\"\n\
  if (index == 15) print \"${navy_rb51}\"\n\
  if (index == 16) print \"${navy_rb45}\"\n\
  if (index == 17) print \"${navy_rb39}\"\n\
  if (index == 18) print \"${navy_rb33}\"\n\
  if (index == 19) print \"${navy_rb27}\"\n\
  if (index == 20) print \"${navy_rb21}\"\n\
  if (index == 21) print \"${navy_rb57}\"\n\
  if (index == 22) print \"${navy_rb93}\"\n\
  if (index == 23) print \"${navy_rb128}\"\n\
  if (index == 24) print \"${navy_rb165}\"\n\
  if (index == 25) print \"${navy_rb201}\"\n\
  if (index == 26) print \"${navy_rb200}\"\n\
  if (index == 27) print \"${navy_rb199}\"\n\
  if (index == 28) print \"${navy_rb198}\"\n\
  if (index == 29) print \"${navy_rb197}\"\n\
}\n\
\
define spin_pattern (index)\n\
{\n\
  if (index ==  0)                 print \" ⠄     \"\n\
  if (index ==  1)                 print \" ⠔     \"\n\
  if (index ==  2)                 print \" ⠐⠁    \"\n\
  if (index ==  3)                 print \"  ⠉    \"\n\
  if (index ==  4)                 print \"  ⠈⠂   \"\n\
  if (index ==  5)                 print \"   ⠢   \"\n\
  if (index ==  6)                 print \"   ⠠⠄  \"\n\
  if (index ==  7)                 print \"    ⠔  \"\n\
  if (index ==  8)                 print \"    ⠐⠁ \"\n\
  if (index ==  9)                 print \"     ⠉ \"\n\
  if (index == 10)                 print \"     ⠘ \"\n\
  if (index == 11)                 print \"     ⠔ \"\n\
  if (index == 12)                 print \"    ⠠⠄ \"\n\
  if (index == 13)                 print \"    ⠢  \"\n\
  if (index == 14)                 print \"   ⠈⠂  \"\n\
  if (index == 15)                 print \"   ⠉   \"\n\
  if (index == 16)                 print \"  ⠐⠁   \"\n\
  if (index == 17)                 print \"  ⠔    \"\n\
  if (index == 18)                 print \" ⠠⠄    \"\n\
  if (index == 19)                 print \" ⠢     \"\n\
  if (index == 20)                 print \" ⠃     \"\n\
  if (index == 21)                 print \" ⠉     \"\n\
  if (index == 22)                 print \" ⠈⠂    \"\n\
  if (index == 23)                 print \"  ⠢    \"\n\
  if (index == 24)                 print \"  ⠠⠄   \"\n\
  if (index == 25)                 print \"   ⠔   \"\n\
  if (index == 26)                 print \"   ⠐⠁  \"\n\
  if (index == 27)                 print \"    ⠉  \"\n\
  if (index == 28)                 print \"    ⠈⠂ \"\n\
  if (index == 29)                 print \"     ⠢ \"\n\
  if (index == 30)                 print \"     ⠠ \"\n\
  if (index >  30 \&\& index < 34) print \"       \"\n\
}\n\
\
define spin (nelapsed, index)\n\
{\n\
  dummy = spin_color ((nelapsed / (5 * ${navy_us_per_ds})) % 30)\n\
  dummy = spin_pattern ((nelapsed / ${navy_us_per_ds}) % 34)\n\
  print \"${navy_white}\"\n\
  dummy = spin_title (index)\n\
  print \"${navy_reset}${navy_erase_until_eol}\"\n\
}\n\
\
for (index = 0; spins_nts [index] != 0; index = index + 1)\n\
{\n\
  nts = spins_nts [index]\n\
  nelapsed = cnts - nts\n\
  ns = nelapsed % ${navy_us_per_s}\n\
  cs = ns / ${navy_us_per_cs}\n\
  elapsed = (nelapsed - ns) / ${navy_us_per_s}\n\
\
  if (index > 0) print \"\\\n\"\n\
\
  if (nelapsed < ${navy_us_per_10s}) print \" \"\n\
  if (nelapsed < ${navy_us_per_min})\n\
  {\n\
    if (cs > 9) { print \"   ${navy_bold}${navy_white}\", elapsed, \".\", cs; dummy = spin (nelapsed, index); continue; }\n\
    if (cs < 10) { print \"   ${navy_bold}${navy_white}\", elapsed, \".0\", cs; dummy = spin (nelapsed, index); continue; }\n\
  }\n\
  if (nelapsed >= ${navy_us_per_min} \&\& nelapsed < ${navy_us_per_10min}) print \" \"\n\
  if (nelapsed >= ${navy_us_per_min} \&\& nelapsed < ${navy_us_per_h})\n\
  {\n\
    sec = elapsed % ${navy_s_per_min}\n\
    if (sec > 9) { print \"   ${navy_bold}${navy_white}\", elapsed / ${navy_s_per_min}, \":\", sec; dummy = spin (nelapsed, index); continue; }\n\
    if (sec < 10) { print \"   ${navy_bold}${navy_white}\", elapsed / ${navy_s_per_min}, \":0\", sec; dummy = spin (nelapsed, index); continue; }\n\
  }\n\
  if (nelapsed >= ${navy_us_per_h} \&\& nelapsed < ${navy_us_per_10h}) print \" \"\n\
  if (nelapsed >= ${navy_us_per_h} \&\& nelapsed < ${navy_us_per_100h})\n\
  {\n\
    sec = elapsed % ${navy_s_per_min}\n\
    min = (elapsed / ${navy_s_per_min}) % ${navy_min_per_h}\n\
    if (sec > 9 \&\& min > 9) { print \"${navy_bold}${navy_white}\", elapsed / ${navy_s_per_h}, \":\", min, \":\", sec; dummy = spin (nelapsed, index); continue; }\n\
    if (sec < 10 \&\& min > 9) { print \"${navy_bold}${navy_white}\", elapsed / ${navy_s_per_h}, \":\", min, \":0\", sec; dummy = spin (nelapsed, index); continue; }\n\
    if (sec > 9 \&\& min < 10) { print \"${navy_bold}${navy_white}\", elapsed / ${navy_s_per_h}, \":0\", min, \":\", sec; dummy = spin (nelapsed, index); continue; }\n\
    if (sec < 10 \&\& min < 10) { print \"${navy_bold}${navy_white}\", elapsed / ${navy_s_per_h}, \":0\", min, \":0\", sec; dummy = spin (nelapsed, index); continue; }\n\
  }\n\
  print \"${navy_bold}${navy_white}--:--:--\"\n\
  dummy = spin (nelapsed, index)\n\
}\n\
for (index = 0; spins_nts [index] != 0; index = index + 1)\n\
{\n\
  print \"${navy_previous}\"\n\
}\n\
print \"\\\a\"\n@; :exit" \
      | BC_LINE_LENGTH='0' command bc -q | command buffered_output
  else
    command ts '%T' | command sed "s@^[0-9][0-9]:[0-9][0-9]:[0-9][0-9] ${navy_rawlevel}@@"
  fi
}

progress_bar ()
{
  :
  # ▏▎▍▌▋▊▉█
  # ▁▁▁▁▁▁▁▁
  # █████  ▕
  # ▔▔▔▔▔▔▔▔
  # ▁▁▁▁▁▁▁▁
  #▕█████   ▎
  # ▔▔▔▔▔▔▔▔
}

cols ()
{
  local tty
  tty="$(command readlink -f "${navy_tty}")"
  COLUMNS="$(command stty -F "${tty}" size | command cut -d ' ' -f 2)"
  COLUMNS="${COLUMNS:-"$(command tput cols)"}"
}

logs ()
{
  local first_max_length_line max_line_length does_line_has_enought_chars eol
  cols

  if not str empty "${1:-}"
  then
    first_max_length_line="$(printf "%$(( ${COLUMNS} + ${#navy_bold} + ${#navy_cyan} + ${#navy_reset} - 9 ))s" | command tr ' ' '.')"
    does_line_has_enought_chars="$(printf "%$(( ${COLUMNS} - 9 ))s" | command sed 's/ /\[^\\n]/g')"
    max_line_length="$(printf "%$(( ${COLUMNS} - 9 ))s" | command tr ' ' '.')"
    set -f
    command sed        "/^${navy_rawlevel}/ {
                          b exit;
                        }
                        s@^${navy_errorlevel}@${navy_red}ERROR ${navy_reset}@;    t header;
                        s@^${navy_warnlevel}@${navy_yellow} WARN ${navy_reset}@;  t header;
                        s@^${navy_infolevel}@${navy_green} INFO ${navy_reset}@;   t header;
                        s@^${navy_notelevel}@${navy_cyan} NOTE ${navy_reset}@;    t header;
                        s@^${navy_debuglevel}@${navy_blue}DEBUG ${navy_reset}@;   t header;
                        s@^${navy_tracelevel}@${navy_purple}TRACE ${navy_reset}@; t header;
                        s@^${navy_verblevel}@${navy_pink} VERB ${navy_reset}@;
               :header; s@^@${navy_bold}@;                                        t reset_T_smaller;
      :reset_T_smaller; s@^${first_max_length_line}@&\n@;                         T smaller; t loop;
                 :loop; s@\n\$@@;                                                 t equal;
                        h;
                        s@\(.\)\n.*@\1@;
                        p;
                        g;
                        s@.*\n@@;
                        s@^@      @;                                              t reset_t_loop;
         :reset_t_loop; /${does_line_has_enought_chars}$/ {
                          s@^${max_line_length}@\0\n@;                            t loop;
                        };
                :equal;
              :smaller;
                 :exit;" ${1}

    command rm -f ${1}
    set +f
  elif not str empty "${2:-}"
  then
    eol="${navy_esc}[${COLUMNS}G"
    printf '%b%b' "${navy_previous}" "${eol}"
  fi
}

_stop ()
{
  local entries
  entries="$(command find "${navy_stops}" -mindepth 1 -maxdepth 1 -type l)"

  if not str empty "${entries:-}"
  then
    set -f
    command rm -f ${entries} $(command readlink -f ${entries})
    set +f
  fi
}

logger ()
{
  trap 'navy_loggerstart=1' USR1

  add_style
  add_time

  local field_logs field_spins logs_entries spins_entries arg_max
  field_logs="$(printf '%s//\n' "${navy_lines}" | command grep -o '/' | command grep -c '/')"
  field_spins="$(printf '%s//\n' "${navy_spins}" | command grep -o '/' | command grep -c '/')"
  arg_max="$(( $(command getconf ARG_MAX) / 4 - 1 ))"

  while str empty "${navy_loggerstart:-}"; do command usleep 10; done

  trap 'navy_loggerstop=1' USR1

  printf '%b' "${navy_hidecursor}"

  while str empty "${navy_loggerstop:-}" || command find "${navy_lines}" -mindepth 1 -maxdepth 1 -type f | read dummy
  do
    logs_entries="$(command find "${navy_lines}" -mindepth 1 -maxdepth 1 -type f | command sort -n -t '/' -k "${field_logs}" | command head -n "${arg_max}")"
    spins_entries="$(command find "${navy_spins}" -mindepth 1 -maxdepth 1 -type f | command sort -n -t '/' -k "${field_spins}" | command xargs -I % cat %)"
    logs "${logs_entries}" "${spins_entries}" | spins "${spins_entries}" 1>&2
    if str empty "${navy_loggerstop:-}"; then _stop; fi
  done

  printf '%b' "${navy_showcursor}"
}

listener ()
{
  local line alias ts i
  until is sym "${navy_tty}" \
    && is dir "${navy_lines}" \
    && is dir "${navy_spins}" \
    && is dir "${navy_aliases}" \
    && is dir "${navy_stops}"; do command usleep 10; done
  while read -r line
  do
    i="$(( ${i:--1} + 1 ))"
    case "${line}" in
    ( K* ) command mv "${navy_aliases}/${line#K}" "${navy_stops}/${i}" ;;
    ( S* )
      line="${line#*/}"
      alias="${line%%/*}"
      line="${line#*/}"
      ts="$(command date '+%s%N')"
      printf '
s@^\(.*\) \(define spin_title (index) {\)\([^}]*\)} \([0-9]*\)$@\\1 spins_nts [\\4] = %s; \\2\\3if (index == \\4) print "%s"; } \\4@;

td%d;
:d%d;
s@9\(_*\)$@_\\1@;
td%d;

s@ \(_\+\)$@ 1\\1@; tn%d;
s@8\(_*\)$@9\\1@; tn%d;
s@7\(_*\)$@8\\1@; tn%d;
s@6\(_*\)$@7\\1@; tn%d;
s@5\(_*\)$@6\\1@; tn%d;
s@4\(_*\)$@5\\1@; tn%d;
s@3\(_*\)$@4\\1@; tn%d;
s@2\(_*\)$@3\\1@; tn%d;
s@1\(_*\)$@2\\1@; tn%d;
s@0\(_*\)$@1\\1@; tn%d;

:n%d;
s@_\(_*\)$@0\\1@;
tn%d;
' "${ts%???}" "$(printf '%s' "${line}" | command sed -e 's@\\@\\\\@g; s@"@\\q@g')" "${i}" "${i}" "${i}" "${i}" "${i}" "${i}" "${i}" "${i}" "${i}" "${i}" "${i}" "${i}" "${i}" "${i}" "${i}" >> "${navy_spins}/${i}"
      command ln -s "${navy_spins}/${i}" "${navy_aliases}/${alias}" ;;
    ( [-0123456]* ) printf '%s\n' "${line}" > "${navy_lines}/${i}" ;;
    ( * ) printf '%s%s\n' "${PS4}" "${line}" > "${navy_lines}/${i}" ;;
    esac
  done
}

send_raw () { ansi2txt | sed "s@^@${navy_rawlevel}@"; }
send_error () { if ge "${navy_loglevel}" "${navy_errorlevel}"; then ansi2txt | sed "s@^@${navy_errorlevel}@" >&3; fi; }
send_warn () { if ge "${navy_loglevel}" "${navy_warnlevel}"; then ansi2txt | sed "s@^@${navy_warnlevel}@" >&3; fi; }
send_info () { if ge "${navy_loglevel}" "${navy_infolevel}"; then ansi2txt | sed "s@^@${navy_infolevel}@" >&3; fi; }
send_note () { if ge "${navy_loglevel}" "${navy_notelevel}"; then ansi2txt | sed "s@^@${navy_notelevel}@" >&3; fi; }
send_debug () { if ge "${navy_loglevel}" "${navy_debuglevel}"; then ansi2txt | sed "s@^@${navy_debuglevel}@" >&3; fi; }
send_verb () { if ge "${navy_loglevel}" "${navy_verblevel}"; then ansi2txt | sed "s@^@${navy_verblevel}@" >&3; fi; }

start_spin () { sed "s@^@S/${1}/@" >&3; }
stop_spin () { printf 'K%s\n' "${1}" >&3; }

help ()
{
  printf "\
A Docker Engine orchestrator

Usage:
  navy [options] [rules]

Rules:
  TODO

Options:
  -f, --file file       navy main file (default: ./navy.yaml)
  -r, --reset-cache     resets the cache
  -v                    verbosity, reusable (default: 3, max: 7)
  -h, --help            help for navy
  -V, --version         version for navy
" | send_raw
  return 1
}

version ()
{
  printf 'navy 0.1.0\n' | send_raw
  return 1
}

help_option ()
{
  navy_help='true'
}

version_option ()
{
  navy_version='true'
}

reset_cache_option ()
{
  navy_resetcache='true'
}

file_option ()
{
  if not is present "${1}"
  then
    printf '%s does not exist\n' "${1}" | send_error
    exit 1
  elif not can read "${1}"
  then
    printf 'You do not have the permission to read %s\n' "${1}" | send_error
    exit 1
  fi
  navy_file="${1}"
}

v_option ()
{
  navy_loglevel="$(( ${navy_loglevel:--1} + 1 ))"
}

add_rule ()
{
  navy_userrules="${navy_userrules:-}${1} "
}

unknown_option ()
{
  printf 'Unknown rule/option: %s\n' "'${1}'" | send_error
  return 1
}

parse_options ()
{
  while not eq "${#}" '0'
  do
    case "${1}" in

    # Handle '-abc' the same as '-a -bc' for short-form no-arg options
    ( -[hrvV]?* )
      IFS=' '
      set -f
      set -- "${1%"${1#??}"}" "-${1#??}" $(shift; printf '%s\n' "${@}")
      set +f
      IFS="${navy_ifs}"
      continue ;;

    # Handle '-foo' the same as '-f oo' for short-form 1-arg options
    ( -[f]?* )
      IFS=' '
      set -f
      set -- "${1%"${1#??}"}" "${1#??}" $(shift; printf '%s\n' "${@}")
      set +f
      IFS="${navy_ifs}"
      continue ;;

    # Handle '--file=file1' the same as '--file file1' for long-form 1-arg options
    ( --file=* )
      IFS=' '
      set -f
      set -- "${1%%=*}" "${1#*=}" $(shift; printf '%s\n' "${@}")
      set +f
      IFS="${navy_ifs}"
      continue ;;

    ( -r|--reset-cache ) reset_cache_option        ;;
    ( -f|--file )        file_option "${2}"; shift ;;
    ( -v )               v_option                  ;;
    ( -h|--help )        help_option               ;;
    ( -V|--version )     version_option            ;;
    ( * )                add_rule "${1}"           ;;
    esac
    shift
  done
}

prepare_curl ()
{
  navy_reqheader='http:/'
  navy_curlresp="${NAVY_RUN_PATH}/curlresponse.json"
  navy_curlopts="${navy_curlopts:+"${navy_curlopts:-}" }--silent --write-out %{http_code} --output ${navy_curlresp}"

  if str empty "${DOCKER_HOST:-}"
  then
    navy_curlopts="${navy_curlopts:+"${navy_curlopts}" }--unix-socket /var/run/docker.sock"
  else
    navy_reqheader="${navy_reqheader}/${DOCKER_HOST#*://}"
  fi

  readonly navy_reqheader navy_curlresp navy_curlopts
}

verbose_eval ()
{
  eval "${1} () { { set +x; } 2> /dev/null; if not command ${1} ${opts:+"${opts}" }\"\${@}\"${pipe:+ 2>&1 | "${pipe}"}; then return 1; fi; set -x; }"
}

prepare_logging ()
{
  if ge "${navy_loglevel}" "${navy_tracelevel}"; then set -x; fi

  if ge "${navy_loglevel}" "${navy_debuglevel}"
  then
    navy_curlopts="--verbose --stderr ${navy_buffer}"
  fi

  local yqopts gomplateopts utilsopt
  yqopts='--no-colors'
  if ge "${navy_loglevel}" "${navy_verblevel}"
  then
    gomplateopts="${gomplateopts:+"${gomplateopts}" }--verbose"
    yqopts="${yqopts:+"${yqopts}" }--verbose"
    utilsopt='-v'
  fi

  if ge "${navy_loglevel}" "${navy_tracelevel}"
  then
    opts="${utilsopt:-}" pipe='send_verb' verbose_eval 'cp'
    opts="${utilsopt:-}" pipe='send_verb' verbose_eval 'mkdir'
    opts="${utilsopt:-}" pipe='send_verb' verbose_eval 'mv'
    opts="${utilsopt:-}" pipe='send_verb' verbose_eval 'rm'
    opts="${gomplateopts:-}" verbose_eval 'gomplate'
    opts="${yqopts:-}" verbose_eval 'yq'
  else
    eval "gomplate () { command gomplate ${gomplateopts:+"${gomplateopts}" }\"\${@}\"; };
          yq () { command yq ${yqopts:+"${yqopts}" }\"\${@}\"; }"
  fi
}

prepare ()
{
  navy_file="${navy_file:-./navy.yaml}"
  navy_loglevel="${navy_loglevel:-"${navy_infolevel}"}"

  printf 'Main file found: %s\n' "${navy_file}" | send_note

  readonly navy_resetcache navy_file navy_loglevel navy_help navy_version navy_userrules

  prepare_logging
  prepare_curl
}

_curl ()
{
  rm -f "${navy_buffer}"

  local out
  if not out="$(set -f; curl ${navy_curlopts} "${@}" "${req}")"
  then
    printf '%s HTTP response: %s\n' "'${req}'" "${out}" | send_error
    if is present "${navy_buffer}"; then cat "${navy_buffer}" | send_error; fi
    return 1
  fi

  if not eq "${out%"${out#?}"}" '2'
  then printf '%s HTTP response: %s\n' "'${req}'" "${out}" | send_warn; fi

  if is nonempty "${navy_buffer}"
  then
    printf '[CURL] HTTP exchange between Navy and Docker Engine:\n' | send_debug
    cat "${navy_buffer}" | send_debug
    printf '[CURL] JSON response from Docker Engine:\n' | send_debug
    command yq --no-colors --input-format 'json' --output-format 'json' "${navy_curlresp}" | send_debug
  fi
}

_yq ()
{
  rm -f "${navy_buffer}"

  if not yq "${@}" 2> "${navy_buffer}"
  then
    printf 'The YAML parser failed with this error:\n' | send_error
    if is present "${navy_buffer}"; then cat "${navy_buffer}" | send_error; fi
    return 1
  elif lt "${navy_loglevel}" "${navy_verblevel}" && is nonempty "${navy_buffer}"
  then
    printf 'The YAML parser succeed but returns this warning:\n' | send_warn
    cat "${navy_buffer}" | send_warn
  elif is nonempty "${navy_buffer}"
  then cat "${navy_buffer}" | send_verb; fi
}

_gom ()
{
  rm -f "${navy_buffer}"

  if not gomplate "${@}" 2> "${navy_buffer}"
  then
    printf 'The Go Template processor failed with this error:\n' | send_error
    if is present "${navy_buffer}"; then command yq --no-colors --input-format 'json' --output-format 'json' "${navy_buffer}" | send_error; fi
    return 1
  elif lt "${navy_loglevel}" "${navy_verblevel}" && is nonempty "${navy_buffer}"
  then
    printf 'The Go Template processor succeed but returns this warning:\n' | send_warn
    command yq --no-colors --input-format 'json' --output-format 'json' "${navy_buffer}" | send_warn
  elif is nonempty "${navy_buffer}"
  then command yq --no-colors --input-format 'json' --output-format 'json' "${navy_buffer}" | send_verb; fi
}

request ()
{
  printf '%s/v%s%s\n' "${navy_reqheader}" "${navy_apiversion:-1.25}" "${1}"
}

get ()
{
  req="$(request "${req}")" _curl --request GET "${@}"
}

prepare_cache ()
{
  navy_cache_exploded="${navy_cache}/exploded.yaml"
  navy_cache_nods="${navy_cache}/nods.yaml"
  navy_cache_escaped="${navy_cache}/escaped.yaml"
  navy_cache_rendered="${navy_cache}/rendered.yaml"

  navy_cache_context="${navy_cache}/context"
  navy_cache_version_json="${navy_cache_context}/version.json"
  navy_cache_info_json="${navy_cache_context}/info.json"

  navy_cache_datasources="${navy_cache}/datasources"
  navy_cache_header="${navy_cache_datasources}/header.yaml"
  navy_cache_dsescaped="${navy_cache_datasources}/escaped.yaml"
  navy_cache_dsgathered="${navy_cache_datasources}/gathered.yaml"
  navy_cache_dsrendered="${navy_cache_datasources}/rendered.yaml"

  readonly navy_cache_exploded navy_cache_nods navy_cache_escaped navy_cache_rendered \
           navy_cache_context navy_cache_version_json navy_cache_info_json \
           navy_cache_datasources navy_cache_header navy_cache_dsescaped navy_cache_dsgathered navy_cache_dsrendered

  mkdir -p "${navy_cache_context}" "${navy_cache_datasources}"

  printf 'Preprocessing: Cache prepared\n' | send_note
}

explode_main_file ()
{
  _yq 'explode(.)' "${navy_file}" > "${navy_cache_exploded}"
  printf 'Preprocessing: Main file exploded\n' | send_note
}

define_context_datasources ()
{
  req='/version' get
  mv -f "${navy_curlresp}" "${navy_cache_version_json}"

  navy_apiversion="$(_gom --datasource "version=${navy_cache_version_json}" --in '{{ (datasource "version").ApiVersion }}')"
  req='/version' get
  mv -f "${navy_curlresp}" "${navy_cache_version_json}"

  req='/info' get
  mv -f "${navy_curlresp}" "${navy_cache_info_json}"

  printf 'Preprocessing: Context datasources defined\n' | send_note
}

write_datasources_header ()
{
  printf '{{ $INFO := (datasource "info") }}{{ $VERSION := (datasource "version") }}' > "${navy_cache_header}"
  _yq '.datasources[] | "{{ $" + .id + " := index (datasource \"header\") \"" + .source + "\" }}"' "${navy_cache_exploded}" | tr -d '\n' >> "${navy_cache_header}"
  _yq '. |= del(.datasources)' "${navy_cache_exploded}" > "${navy_cache_nods}"
  printf 'Preprocessing: Datasources header written\n' | send_note
}

expand_datasources_into_datasources ()
{
  local datasources gathered_sha rendered_sha
  gathered_sha='0'
  rendered_sha='1'
  datasources="$(_yq '.datasources[].source' "${navy_cache_exploded}")"

  set -f
  _yq -N '{filename: explode(.)} | ... style="single"' ${datasources} > "${navy_cache_dsrendered}"
  set +f

  until eq "${gathered_sha}" "${rendered_sha}"
  do
    cp -f "${navy_cache_dsrendered}" "${navy_cache_dsgathered}"
    cp -f "${navy_cache_header}" "${navy_cache_dsescaped}"

    _yq '(.. | key = "{{ print \"" + key + "\" }}") |= .' "${navy_cache_dsgathered}" >> "${navy_cache_dsescaped}"

    _gom --datasource "header=${navy_cache_dsgathered}" --datasource "info=${navy_cache_info_json}" --datasource "version=${navy_cache_version_json}" --file "${navy_cache_dsescaped}" --out "${navy_cache_dsrendered}"

    gathered_sha="$(sha256sum "${navy_cache_dsgathered}")"
    gathered_sha="${gathered_sha%% *}"
    rendered_sha="$(sha256sum "${navy_cache_dsrendered}")"
    rendered_sha="${rendered_sha%% *}"
  done

  printf 'Preprocessing: Datasources expanded\n' | send_note
}

expand_datasources_into_main ()
{
  cp -f "${navy_cache_header}" "${navy_cache_escaped}"

  # do not process templates into rules[].run[]
  _yq '(.. | key = "{{ print \"" + key + "\" }}") |= . | ((select(has("{{ print \"rules\" }}")) | .["{{ print \"rules\" }}"][]) |= (select(has("{{ print \"run\" }}")) | .["{{ print \"run\" }}"]) |= (.. | select (type == "!!str") |= "{{ print \"" + . + "\" }}"))' "${navy_cache_nods}" >> "${navy_cache_escaped}"
  _gom --datasource "header=${navy_cache_dsrendered}" --datasource "info=${navy_cache_info_json}" --datasource "version=${navy_cache_version_json}" --file "${navy_cache_escaped}" --out "${navy_cache_rendered}"

  printf 'Preprocessing: Datasources expanded into main file\n' | send_note
}

expand_anchors ()
{
  :
  # resolve 'anchors' keywords
  #   - explode anchors and aliases
}

check_linear_includes ()
{
  :
  # check circular dependencies between includes
}

expand_datasources_into_includes ()
{
  :
  # resolve datasources in included files (not for Requests & Commands)
}

expand_includes ()
{
  :
  # resolve 'includes' keywords
}

expand_extends ()
{
  :
  # change loop run and run[].loop into dictionnaries to:
  #   resolve 'extends' (replace them with anchors and aliases then use yq explode)
}

generate_sh ()
{
  :
  # yq script to generate sh script.
}

init ()
{
  set -eu

  navy_ifs="${IFS}"
  navy_nl='
'
  NAVY_CACHE_PATH="${NAVY_CACHE_PATH:-/var/cache/navy}"
  NAVY_RUN_PATH="${NAVY_RUN_PATH:-/var/run/navy}"
  navy_sha="$(find . -type f -exec sha256sum {} \; | sha256sum)"
  navy_sha="${navy_sha%% *}"
  navy_cache="${NAVY_CACHE_PATH}/${navy_sha}"
  navy_logs="${NAVY_RUN_PATH}/logs"
  navy_lines="${navy_logs}/lines"
  navy_spins="${NAVY_RUN_PATH}/spins"
  navy_stops="${NAVY_RUN_PATH}/stops"
  navy_aliases="${NAVY_RUN_PATH}/aliases"
  navy_tty="${NAVY_RUN_PATH}/tty"
  navy_buffer="${NAVY_RUN_PATH}/buffer"
  navy_done="${NAVY_RUN_PATH}/done"
  navy_rawlevel='-'
  navy_errorlevel='0'
  navy_warnlevel='1'
  navy_infolevel='2'
  navy_notelevel='3'
  navy_debuglevel='4'
  navy_tracelevel='5'
  navy_verblevel='6'
  readonly NAVY_CACHE_PATH NAVY_RUN_PATH navy_sha navy_cache navy_logs navy_lines navy_spins navy_stops navy_aliases navy_tty navy_buffer navy_done navy_ifs navy_nl \
           navy_rawlevel navy_errorlevel navy_warnlevel navy_infolevel navy_notelevel navy_debuglevel navy_tracelevel navy_verblevel

  PS4="${navy_tracelevel}"

  mkdir -p "${NAVY_CACHE_PATH}" "${NAVY_RUN_PATH}"
}

not_cached ()
{
  if eq "${navy_resetcache:-}" 'true' || not is present "${navy_done}"; then return 0; else return 1; fi
}

init_runner ()
{
  exec 3>&2
  rm -r -f "${NAVY_RUN_PATH}/"*
  mkdir -p "${navy_cache}" "${navy_logs}" "${navy_lines}" "${navy_spins}" "${navy_stops}" "${navy_aliases}"
  ln -s "$(tty)" "${navy_tty}"
  kill -s USR1 "${navy_loggerpid}"
}

preprocess ()
{
  if not_cached
  then
    # TODO: use cache when failure: do not do compute the cache again
    printf 'Preprocessing ...\n' | start_spin 'cache'
    prepare_cache
    explode_main_file
    define_context_datasources
    write_datasources_header
    expand_datasources_into_datasources
    expand_datasources_into_main
    expand_anchors
    check_linear_includes
    expand_datasources_into_includes
    expand_includes
    expand_extends
    generate_sh
    stop_spin 'cache'
  fi
}

run ()
{
  # current CLI:
  # CWD="${PWD}" ./navy

  # depending of parsed options:
  # - run sh script with: seq 1 10 | xargs --max-args 1 --max-procs "$(( $(nproc) + 1 ))" ./script
  # - or use git to see dependencies as a tree ???
  if eq "${navy_help:-}" 'true'
  then
    help
  elif eq "${navy_version:-}" 'true'
  then
    version
  else
    IFS=' '
    set -f
    set -- ${navy_userrules:-}
    set +f
    IFS="${navy_ifs}"
    while not eq "${#}" '0'
    do
      case " ${navy_rules:-} " in
      ( *" ${1} "* ) : ;; #TODO
      ( * ) unknown_option "${1}" ;;
      esac
      shift
    done
  fi
}

runner ()
{
  init_runner
  parse_options "${@}"
  prepare
  preprocess
  run
}

main ()
{
  init
  logger &
  navy_loggerpid="${!}"
  readonly navy_loggerpid
  trap "kill -s USR1 ${navy_loggerpid}; wait" EXIT INT TERM
  { runner "${@}"; } 2>&1 | listener
}

main "${@}"

# ----------------------------------------------------------------------------
# MEMO
# ----------------------------------------------------------------------------
#
# regular:
# curl -s --unix-socket /var/run/docker.sock -X DELETE http://v1.45/containers/hardcore_jang?force=true
#
# filters/urlencode:
# curl -s --unix-socket /var/run/docker.sock 'http://1.45/images/json' -X GET -G --data-urlencode 'filters={"reference":{"172.17.2.3:5000/mywhalefleet/tiawl.local.*":true}}'
#
# attach: curl -s -N -T - -X POST --unix-socket ./docker.sock 'http://1.45/containers/aaebdff75c380b80556b9c2ce65b2c62ba4cdd59427d3f269d5a61d7b8a087b0/attach?stdout=1&stdin=1&stderr=1&stream=1' -H 'Upgrade: tcp' -H 'Connection: Upgrade'
#
# build:
# tar c -f context.tar -C /tmp .
# curl -s --data-binary @- --header 'Content-Type: application/x-tar' --no-buffer --unix-socket /var/run/docker.sock -X POST http://v1.45/build?dockerfile=Dockerfile&t=reg/proj/my-img:my-tag < context.tar
