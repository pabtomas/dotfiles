#! /usr/bin/env dash

add_style ()
{
  red="$(printf '\033[38;5;204m')"
  yellow="$(printf '\033[38;5;228m')"
  green="$(printf '\033[38;5;120m')"
  blue="$(printf '\033[38;5;105m')"
  bold="$(printf '\033[1m')"
  reset="$(printf '\033[m')"
  time_format='%H:%M:%S'

  readonly red yellow green blue bold reset time_format
}

error ()
{
  if [ -r "${1}" ]
  then
    sed "s@^@${red}${bold}ERROR${reset} @" "${1}"
  else
    printf '%b%bERROR%b %s\n' "${red}" "${bold}" "${reset}" "${1}" 1>&2
  fi | ts "${time_format}"
}

warn ()
{
  if [ "${log_level}" -gt 0 ]
  then
    if [ -r "${1}" ]
    then
      sed "s@^@${yellow}${bold}WARN${reset} @" "${1}"
    else
      printf '%b%bWARN%b %s\n' "${yellow}" "${bold}" "${reset}" "${1}" 1>&2
    fi | ts "${time_format}"
  fi
}

info ()
{
  if [ "${log_level}" -gt 1 ]
  then
    if [ -r "${1}" ]
    then
      sed "s@^@${green}${bold}INFO${reset} @" "${1}"
    else
      printf '%b%bINFO%b %s\n' "${green}" "${bold}" "${reset}" "${1}"
    fi | ts "${time_format}"
  fi
}

debug ()
{
  if [ "${log_level}" -gt 2 ]
  then
    if [ -r "${1}" ]
    then
      sed "s@^@${blue}${bold}DEBUG${reset} @" "${1}"
    else
      printf '%b%bDEBUG%b %s\n' "${blue}" "${bold}" "${reset}" "${1}"
    fi | ts "${time_format}"
  fi
}

help_option ()
{
  printf "\
A Docker Engine orchestrator

Usage:
  navy [flags]

Flags:
  --file file        navy main file (default: ./navy.yaml).
  --ignore-cache     ignores the cache.
  -v                 prints only ERROR messages.
  -v -v              prints ERROR and WARNING messages.
  -v -v -v           prints ERROR, WARNING, and INFO messages (default).
  -v -v -v -v        prints ERROR, WARNING, INFO and DEBUG messages.
  --help             help for navy.
  --version          version for navy.
"
  return 1
}

version_option ()
{
  printf 'navy 0.1.0\n'
  return 1
}

ignore_cache_option ()
{
  ignore_cache='true'
}

file_option ()
{
  if [ ! -e "${1}" ]
  then
    error "${1} does not exist"
    exit 1
  elif [ ! -r "${1}" ]
  then
    error "You do not have the permission to read ${1}"
    exit 1
  fi
  file="${1}"
}

v_option ()
{
  log_level="$(( ${log_level:--1} + 1 ))"
}

unknown_option ()
{
  error "Unknown option: '${1}'"
  return 1
}

parse_options ()
{
  while [ "${#}" != '0' ]
  do
    case "${1}" in

    # Handle '-abc' the same as '-a -bc' for short-form no-arg options
    ( -[v]?* )
      IFS=' '
      set -f
      set -- "${1%"${1#??}"}" "-${1#??}" $(shift; printf '%s\n' "${@}")
      set +f
      IFS="${ifs}"
      continue ;;

    # Handle '--file=file1' the same as '--file file1' for long-form 1-arg options
    ( --file=* )
      IFS=' '
      set -f
      set -- "${1%%=*}" "${1#*=}" $(shift; printf '%s\n' "${@}")
      set +f
      IFS="${ifs}"
      continue ;;

    ( --ignore-cache ) ignore_cache_option ;;
    ( --file ) file_option "${2}"; shift ;;
    ( -v ) v_option ;;
    ( --help ) help_option ;;
    ( --version ) version_option ;;
    ( * ) unknown_option "${1}" ;;
    esac
    shift
  done
}

prepare_curl ()
{
  local tmp
  tmp="$(mktemp -d)"

  request_header='http:/'
  curl_response="${tmp}/response.http"
  curl_stderr="${tmp}/stderr.http"
  curl_options="--silent --write-out %{http_code} --output ${curl_response}"

  if [ -z "${DOCKER_HOST:-}" ]
  then
    curl_options="${curl_options} --unix-socket /var/run/docker.sock"
  else
    request_header="${request_header}/${DOCKER_HOST#*://}"
  fi

  if [ "${log_level}" -gt 2 ]
  then
    curl_options="${curl_options} --verbose --stderr ${curl_stderr}"
  fi

  readonly request_header curl_options curl_response curl_stderr
}

prepare ()
{
  file="${file:-./navy.yaml}"
  log_level="${log_level:-2}"
  NAVY_CACHE_PATH="${NAVY_CACHE_PATH:-/var/cache/navy}"

  readonly ignore_cache file log_level NAVY_CACHE_PATH

  prepare_curl
}

compute_checksum ()
{
  cache="${NAVY_CACHE_PATH}/$(find . -type f -exec sha256sum {} \; | sha256sum)"
  cache="${cache%% *}"
  readonly cache
}

create_cache ()
{
  rm -r -f "${cache}"
  mkdir -p "${cache}"
}

_curl ()
{
  rm -f "${curl_stderr}"

  local response log
  response="$(set -f; curl ${curl_options} "${@}" "${req}")"

  if [ "${response%"${response#?}"}" = '2' ]
  then log='info'
  else log='warn'; fi

  ${log} "'${req}' HTTP response: ${response}"

  if [ -s "${curl_stderr}" ]; then debug "${curl_stderr}"; fi
}

request ()
{
  printf '%s/v%s%s\n' "${request_header}" "${api_version:-1.25}" "${1}"
}

get ()
{
  req="$(request "${req}")" _curl --request GET "${@}"
}

define_context_datasources ()
{
  local context version_json info_json
  context="${cache}/context"
  version_json="${context}/version.json"
  info_json="${context}/info.json"
  mkdir -p "${context}"

  req='/version' get
  mv -f "${curl_response}" "${version_json}"

  api_version="$(gomplate --datasource "version=${version_json}" --in '{{ (datasource "version").ApiVersion }}')"
  req='/version' get
  mv -f "${curl_response}" "${version_json}"

  req='/info' get
  mv -f "${curl_response}" "${info_json}"
}

expand_datasources_into_datasources ()
{
  :
  # gomplate to resolve GO templates with datasources:
  #   Use this CLI to expand templates into values but not in keys (improve
  #   it to works (recursively) with dictionaries):
  #   $ yq '. | to_entries[] | "{{ print \"" + .key + "\" }}:" + .value' bases.yaml | gomplate -d bases.yaml=bases.yaml
}

expand_datasources_into_main ()
{
  :
  # resolve datasources in main Navy file
}

expand_anchors ()
{
  :
  # resolve 'anchors' keywords
  #   - explode anchors and aliases
}

check_linear_includes ()
{
  :
  # check circular dependencies between includes
}

expand_datasources_into_includes ()
{
  :
  # resolve datasources in included files
}

expand_includes ()
{
  :
  # resolve 'includes' keywords
}

expand_extends ()
{
  :
  # change loop run and run[].loop into dictionnaries to:
  #   resolve 'extends' (replace them with anchors and aliases then use yq explode)
}

generate_sh ()
{
  :
  # yq script to generate sh script.
}

init ()
{
  set -eu
  # set -x
  ifs="${IFS}"
  readonly ifs
}

not_cached ()
{
  if [ "${ignore_cache:-}" = 'true' ] || [ ! -d "${cache}" ]; then return 0; else return 1; fi
}

main ()
{
  init
  add_style
  parse_options "${@}"
  prepare
  compute_checksum

  if not_cached
  then
    create_cache
    define_context_datasources
    expand_datasources_into_datasources
    expand_datasources_into_main
    expand_anchors
    check_linear_includes
    expand_datasources_into_includes
    expand_includes
    expand_extends
    generate_sh
  fi

  # depending of parsed options:
  # - run sh script with: seq 1 10 | xargs --max-args 1 --max-procs "$(( $(nproc) + 1 ))" ./script
  # - or use git to see dependencies as a tree
}

main "${@}"

# ----------------------------------------------------------------------------
# MEMO
# ----------------------------------------------------------------------------
#
# regular:
# curl -s --unix-socket /var/run/docker.sock -X DELETE http://v1.45/containers/hardcore_jang?force=true
#
# filters/urlencode:
# curl -s --unix-socket /var/run/docker.sock 'http://1.45/images/json' -X GET -G --data-urlencode 'filters={"reference":{"172.17.2.3:5000/mywhalefleet/tiawl.local.*":true}}'
#
# attach: curl -s -N -T - -X POST --unix-socket ./docker.sock 'http://1.45/containers/aaebdff75c380b80556b9c2ce65b2c62ba4cdd59427d3f269d5a61d7b8a087b0/attach?stdout=1&stdin=1&stderr=1&stream=1' -H 'Upgrade: tcp' -H 'Connection: Upgrade'
#
# build:
# tar c -f context.tar -C /tmp .
# curl -s --data-binary @- --header 'Content-Type: application/x-tar' --no-buffer --unix-socket /var/run/docker.sock -X POST http://v1.45/build?dockerfile=Dockerfile&t=reg/proj/my-img:my-tag < context.tar
#
# characters:
# - ▏▎▍▌▋▊▉
# - ┏┓━┃┗┛
