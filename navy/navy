#! /usr/bin/env dash

add_style ()
{
  navy_red="$(printf '\033[38;5;204m')"
  navy_yellow="$(printf '\033[38;5;228m')"
  navy_green="$(printf '\033[38;5;120m')"
  navy_cyan="$(printf '\033[38;5;45m')"
  navy_blue="$(printf '\033[38;5;105m')"
  navy_purple="$(printf '\033[38;5;135m')"
  navy_bold="$(printf '\033[1m')"
  navy_reset="$(printf '\033[m')"
  navy_timefmt='%H:%M:%S'

  readonly navy_red navy_yellow navy_green navy_cyan navy_blue navy_purple navy_bold navy_reset navy_timefmt
}

log ()
{
  if [ "${navy_loglevel}" -ge "${min}" ]
  then
    if [ "${#}" = '0' ]
    then command cat
    elif [ -r "${1}" ]
    then
      if [ -n "${fmt:-}" ]
      then command yq --colors --input-format "${fmt}" --output-format "${fmt}" "${1}"
      else command cat "${1}"; fi
    else printf '%s\n' "${1}"
    fi | command sed "s@^@${color}${navy_bold}${text}${navy_reset} @" | command ts "${navy_timefmt}" 1>&"${fd}"
  fi
  if [ "${navy_loglevel}" -ge 4 ]; then set -x; fi
}

error () { { set +x; } 2> /dev/null; min='0' color="${navy_red}" text='ERROR' fd='4' log "${@}"; }
warn () { { set +x; } 2> /dev/null; min='1' color="${navy_yellow}" text='WARN' fd='4' log "${@}"; }
info () { { set +x; } 2> /dev/null; min='2' color="${navy_green}" text='INFO' fd='3' log "${@}"; }
debug () { { set +x; } 2> /dev/null; min='3' color="${navy_cyan}" text='DEBUG' fd='3' log "${@}"; }
verb () { { set +x; } 2> /dev/null; min='5' color="${navy_purple}" text='VERB' fd='3' log "${@}"; }

spin ()
{
  :
  # ⠧ ⠏ ⠛ ⠹ ⠼ ⠶
}

progress_bar ()
{
  :
  # ▏▎▍▌▋▊▉█
  # ▁▁▁▁▁▁▁▁
  # █████  ▕
  # ▔▔▔▔▔▔▔▔
  # ▁▁▁▁▁▁▁▁
  #▕█████   ▎
  # ▔▔▔▔▔▔▔▔
}

help_option ()
{
  printf "\
A Docker Engine orchestrator

Usage:
  navy [flags]

Flags:
  --file file         navy main file (default: ./navy.yaml).
  --ignore-cache      ignores the cache.
  -v                  prints only ERROR messages.
  -v -v               prints ERROR and WARN messages.
  -v -v -v            prints ERROR, WARN, and INFO messages (default).
  -v -v -v -v         prints ERROR, WARN, INFO and DEBUG messages.
  -v -v -v -v -v      prints ERROR, WARN, INFO, DEBUG and TRACE messages.
  -v -v -v -v -v -v   prints ERROR, WARN, INFO, DEBUG, TRACE and VERB messages.
  --help              help for navy.
  --version           version for navy.
"
  return 1
}

version_option ()
{
  printf 'navy 0.1.0\n'
  return 1
}

ignore_cache_option ()
{
  navy_ignorecache='true'
}

file_option ()
{
  if [ ! -e "${1}" ]
  then
    error "${1} does not exist"
    exit 1
  elif [ ! -r "${1}" ]
  then
    error "You do not have the permission to read ${1}"
    exit 1
  fi
  navy_file="${1}"
}

v_option ()
{
  navy_loglevel="$(( ${navy_loglevel:--1} + 1 ))"
}

unknown_option ()
{
  error "Unknown option: '${1}'"
  return 1
}

parse_options ()
{
  while [ "${#}" != '0' ]
  do
    case "${1}" in

    # Handle '-abc' the same as '-a -bc' for short-form no-arg options
    ( -[v]?* )
      IFS=' '
      set -f
      set -- "${1%"${1#??}"}" "-${1#??}" $(shift; printf '%s\n' "${@}")
      set +f
      IFS="${navy_ifs}"
      continue ;;

    # Handle '--file=file1' the same as '--file file1' for long-form 1-arg options
    ( --file=* )
      IFS=' '
      set -f
      set -- "${1%%=*}" "${1#*=}" $(shift; printf '%s\n' "${@}")
      set +f
      IFS="${navy_ifs}"
      continue ;;

    ( --ignore-cache ) ignore_cache_option ;;
    ( --file ) file_option "${2}"; shift ;;
    ( -v ) v_option ;;
    ( --help ) help_option ;;
    ( --version ) version_option ;;
    ( * ) unknown_option "${1}" ;;
    esac
    shift
  done
}

prepare_cache ()
{
  NAVY_CACHE_PATH="${NAVY_CACHE_PATH:-/var/cache/navy}"
  navy_cache="${NAVY_CACHE_PATH}/$(find . -type f -exec sha256sum {} \; | sha256sum)"
  navy_cache="${navy_cache%% *}"
  navy_run="${navy_cache}/run"
  navy_buffer="${navy_run}/buffer"
  navy_done="${navy_run}/done"
  readonly NAVY_CACHE_PATH navy_cache navy_run navy_buffer navy_done
}

prepare_curl ()
{
  navy_reqheader='http:/'
  navy_curlresponse="${navy_run}/response.http"
  navy_curlopts="--silent --write-out %{http_code} --output ${navy_curlresponse}"

  if [ -z "${DOCKER_HOST:-}" ]
  then
    navy_curlopts="${navy_curlopts}${navy_curlopts:+ }--unix-socket /var/run/docker.sock"
  else
    navy_reqheader="${navy_reqheader}/${DOCKER_HOST#*://}"
  fi

  readonly navy_reqheader navy_curlresponse
}

prepare_logging ()
{
  if [ "${navy_loglevel}" -gt 2 ]
  then
    navy_curlopts="${navy_curlopts}${navy_curlopts:+ }--verbose --stderr ${navy_buffer}"
  fi

  readonly navy_curlopts

  if [ "${navy_loglevel}" -gt 3 ]
  then
    PS4="\$(date +%H:%M:%S) ${navy_blue}${navy_bold}TRACE${navy_reset} "
    set -x
  fi

  local yqopts gomplateopts
  yqopts='--no-colors'
  gomplateopts=''
  if [ "${navy_loglevel}" -gt 4 ]
  then
    gomplateopts="${gomplateopts}${gomplateopts:+ }--verbose"
    yqopts="${yqopts}${yqopts:+ }--verbose"
    mv () { { set +x; } 2> /dev/null; command mv -v "${@}" | verb; set -x; }
    rm () { { set +x; } 2> /dev/null; command rm -v "${@}" | verb; set -x; }
    mkdir () { { set +x; } 2> /dev/null; command mkdir -v "${@}" | verb; set -x; }
  fi

  eval "gomplate () { command gomplate ${gomplateopts} \"\${@}\" 2> ${navy_buffer}; };
        yq () { command yq ${yqopts} \"\${@}\" 2> ${navy_buffer}; }"
}

prepare ()
{
  navy_file="${navy_file:-./navy.yaml}"
  navy_loglevel="${navy_loglevel:-2}"

  readonly navy_ignorecache navy_file navy_loglevel

  prepare_cache
  prepare_curl
  prepare_logging
}

_curl ()
{
  rm -f "${navy_buffer}"

  local response
  response="$(set -f; curl ${navy_curlopts} "${@}" "${req}")"

  if [ "${response%"${response#?}"}" != '2' ]
  then warn "'${req}' HTTP response: ${response}"; fi

  if [ -s "${navy_buffer}" ]; then debug "${navy_buffer}"; fi
}

_yq ()
{
  rm -f "${navy_buffer}"

  if ! yq "${@}"
  then
    error 'The YAML parser failed with this error:'
    error "${navy_buffer}"
    return 1
  elif [ -s "${navy_buffer}" ]
  then
    verb "${navy_buffer}"
    if [ "${navy_loglevel}" -le 3 ]
    then
      warn 'The YAML parser succeed but returns this warning:'
      warn "${navy_buffer}"
    fi
  fi
}

_gom ()
{
  rm -f "${navy_buffer}"

  if ! gomplate "${@}"
  then
    error 'The Go Template processor failed with this error:'
    fmt='json' error "${navy_buffer}"
    return 1
  elif [ -s "${navy_buffer}" ]
  then
    fmt='json' verb "${navy_buffer}"
    if [ "${navy_loglevel}" -le 3 ]
    then
      warn 'The Go Template processor succeed but returns this warning:'
      fmt='json' warn "${navy_buffer}"
    fi
  fi
}

request ()
{
  printf '%s/v%s%s\n' "${navy_reqheader}" "${navy_apiversion:-1.25}" "${1}"
}

get ()
{
  req="$(request "${req}")" _curl --request GET "${@}"
}

reset_cache ()
{
  rm -r -f "${navy_cache}"
  mkdir -p "${navy_cache}" "${navy_run}"
  navy_exploded="${navy_cache}/navy.yaml"
  readonly navy_exploded
  _yq 'explode(.)' "${navy_file}" > "${navy_exploded}"
}

define_context_datasources ()
{
  local context version_json info_json
  context="${navy_cache}/context"
  version_json="${context}/version.json"
  info_json="${context}/info.json"

  mkdir -p "${context}"

  req='/version' get
  mv -f "${navy_curlresponse}" "${version_json}"

  navy_apiversion="$(_gom --datasource "version=${version_json}" --in '{{ (datasource "version").ApiVersion }}')"
  req='/version' get
  mv -f "${navy_curlresponse}" "${version_json}"

  req='/info' get
  mv -f "${navy_curlresponse}" "${info_json}"
}

expand_datasources_into_datasources ()
{
  local datasources header ds escaped_ds
  datasources="${navy_cache}/datasources"

  mkdir -p "${datasources}"

  header="$(_yq '.datasources[] | "{{ $" + .id + " := (datasource \"" + .source + "\") }}"' "${navy_exploded}" | tr -d '\n')"

  for ds in $(_yq '.datasources[].source' "${navy_exploded}")
  do
    mkdir -p "${datasources}/$(dirname -- "${ds}")"
    escaped_ds="$(_yq '(explode(.) | .. | key = "{{ print \"" + key + "\" }}") |= .' "${ds}")"
    printf '%s%s\n' "${header}" "${escaped_ds}" | _gom $(_yq '.datasources[] | "--datasource " + .source + "=" + .source + " "' "${navy_exploded}" | tr '\n' ' ') --out "${datasources}/${ds}"

    # TODO: resolve templates recursively
    # current CLI:
    # CWD="${PWD}" ./navy
  done
}

expand_datasources_into_main ()
{
  :
  # resolve datasources in main Navy file (not for Requests & Commands)
}

expand_anchors ()
{
  :
  # resolve 'anchors' keywords
  #   - explode anchors and aliases
}

check_linear_includes ()
{
  :
  # check circular dependencies between includes
}

expand_datasources_into_includes ()
{
  :
  # resolve datasources in included files (not for Requests & Commands)
}

expand_includes ()
{
  :
  # resolve 'includes' keywords
}

expand_extends ()
{
  :
  # change loop run and run[].loop into dictionnaries to:
  #   resolve 'extends' (replace them with anchors and aliases then use yq explode)
}

generate_sh ()
{
  :
  # yq script to generate sh script.
}

init ()
{
  set -eu
  exec 3>&1
  exec 4>&2
  navy_ifs="${IFS}"
  readonly navy_ifs
}

not_cached ()
{
  if [ "${navy_ignorecache:-}" = 'true' ] || [ ! -e "${navy_done}" ]; then return 0; else return 1; fi
}

main ()
{
  init
  add_style
  parse_options "${@}"
  prepare

  if not_cached
  then
    reset_cache
    define_context_datasources
    expand_datasources_into_datasources
    expand_datasources_into_main
    expand_anchors
    check_linear_includes
    expand_datasources_into_includes
    expand_includes
    expand_extends
    generate_sh
  fi

  # depending of parsed options:
  # - run sh script with: seq 1 10 | xargs --max-args 1 --max-procs "$(( $(nproc) + 1 ))" ./script
  # - or use git to see dependencies as a tree
}

main "${@}"

# ----------------------------------------------------------------------------
# MEMO
# ----------------------------------------------------------------------------
#
# regular:
# curl -s --unix-socket /var/run/docker.sock -X DELETE http://v1.45/containers/hardcore_jang?force=true
#
# filters/urlencode:
# curl -s --unix-socket /var/run/docker.sock 'http://1.45/images/json' -X GET -G --data-urlencode 'filters={"reference":{"172.17.2.3:5000/mywhalefleet/tiawl.local.*":true}}'
#
# attach: curl -s -N -T - -X POST --unix-socket ./docker.sock 'http://1.45/containers/aaebdff75c380b80556b9c2ce65b2c62ba4cdd59427d3f269d5a61d7b8a087b0/attach?stdout=1&stdin=1&stderr=1&stream=1' -H 'Upgrade: tcp' -H 'Connection: Upgrade'
#
# build:
# tar c -f context.tar -C /tmp .
# curl -s --data-binary @- --header 'Content-Type: application/x-tar' --no-buffer --unix-socket /var/run/docker.sock -X POST http://v1.45/build?dockerfile=Dockerfile&t=reg/proj/my-img:my-tag < context.tar
