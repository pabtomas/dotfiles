#! /usr/bin/env dash

add_style ()
{
  navy_esc="$(printf '\033')"
  navy_white="${navy_esc}[38;5;15m"
  navy_red="${navy_esc}[38;5;204m"
  navy_yellow="${navy_esc}[38;5;228m"
  navy_green="${navy_esc}[38;5;120m"
  navy_cyan="${navy_esc}[38;5;045m"
  navy_blue="${navy_esc}[38;5;105m"
  navy_purple="${navy_esc}[38;5;135m"
  navy_bold="${navy_esc}[1m"
  navy_erase_until_eol="${navy_esc}[K"
  navy_sol="${navy_esc}[F"
  navy_hidecursor="${navy_esc}[?25l"
  navy_showcursor="${navy_esc}[?25h"
  navy_reset="${navy_esc}[m"

  navy_rb196="${navy_esc}[38;5;196m"
  navy_rb202="${navy_esc}[38;5;202m"
  navy_rb208="${navy_esc}[38;5;208m"
  navy_rb214="${navy_esc}[38;5;214m"
  navy_rb220="${navy_esc}[38;5;220m"
  navy_rb226="${navy_esc}[38;5;226m"
  navy_rb190="${navy_esc}[38;5;190m"
  navy_rb154="${navy_esc}[38;5;154m"
  navy_rb118="${navy_esc}[38;5;118m"
  navy_rb82="${navy_esc}[38;5;082m"
  navy_rb46="${navy_esc}[38;5;046m"
  navy_rb47="${navy_esc}[38;5;047m"
  navy_rb48="${navy_esc}[38;5;048m"
  navy_rb49="${navy_esc}[38;5;049m"
  navy_rb50="${navy_esc}[38;5;050m"
  navy_rb51="${navy_esc}[38;5;051m"
  navy_rb45="${navy_esc}[38;5;045m"
  navy_rb39="${navy_esc}[38;5;039m"
  navy_rb33="${navy_esc}[38;5;033m"
  navy_rb27="${navy_esc}[38;5;027m"
  navy_rb21="${navy_esc}[38;5;021m"
  navy_rb57="${navy_esc}[38;5;057m"
  navy_rb93="${navy_esc}[38;5;093m"
  navy_rb128="${navy_esc}[38;5;129m"
  navy_rb165="${navy_esc}[38;5;165m"
  navy_rb201="${navy_esc}[38;5;201m"
  navy_rb200="${navy_esc}[38;5;200m"
  navy_rb199="${navy_esc}[38;5;199m"
  navy_rb198="${navy_esc}[38;5;198m"
  navy_rb197="${navy_esc}[38;5;197m"

  readonly navy_white navy_red navy_yellow navy_green navy_cyan navy_blue navy_purple \
           navy_bold \
           navy_erase_until_eol navy_sol \
           navy_hidecursor navy_showcursor \
           navy_reset \
           navy_rb196 navy_rb202 navy_rb208 navy_rb214 navy_rb220 navy_rb226 \
           navy_rb190 navy_rb154 navy_rb118 navy_rb82 navy_rb46 navy_rb47 \
           navy_rb48 navy_rb49 navy_rb50 navy_rb51 navy_rb45 navy_rb39 \
           navy_rb33 navy_rb27 navy_rb21 navy_rb57 navy_rb93 navy_rb128 \
           navy_rb165 navy_rb201 navy_rb200 navy_rb199 navy_rb198 navy_rb197
}

spins ()
{
  local entries cnts_bc
  entries="$(command find "${navy_spins}" -mindepth 1 -maxdepth 1 -type f | command sort -n -t '/' -k "${1}")"

  if [ -n "${entries:-}" ]
  then
    cnts_bc="${NAVY_RUN_PATH}/cnts.bc"
    command sed "s@^@\n${navy_sol}@; s@\$@${navy_erase_until_eol}@"
    command date '+cnts = %s%N' > "${cnts_bc}"
    set -f
    BC_ENV_ARGS="${cnts_bc}" BC_LINE_LENGTH='0' command bc -q ${entries} \
      | command sed "
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 0 \(.*\)\$@\1 ⠄     ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 1 \(.*\)\$@\1 ⠔     ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 2 \(.*\)\$@\1 ⠐⠁    ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 3 \(.*\)\$@\1  ⠉    ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 4 \(.*\)\$@\1  ⠈⠂   ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 5 \(.*\)\$@\1   ⠢   ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 6 \(.*\)\$@\1   ⠠⠄  ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 7 \(.*\)\$@\1    ⠔  ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 8 \(.*\)\$@\1    ⠐⠁ ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 9 \(.*\)\$@\1     ⠉ ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 10 \(.*\)\$@\1     ⠘ ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 11 \(.*\)\$@\1     ⠔ ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 12 \(.*\)\$@\1    ⠠⠄ ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 13 \(.*\)\$@\1    ⠢  ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 14 \(.*\)\$@\1   ⠈⠂  ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 15 \(.*\)\$@\1   ⠉   ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 16 \(.*\)\$@\1  ⠐⠁   ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 17 \(.*\)\$@\1  ⠔    ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 18 \(.*\)\$@\1 ⠠⠄    ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 19 \(.*\)\$@\1 ⠢     ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 20 \(.*\)\$@\1 ⠃     ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 21 \(.*\)\$@\1 ⠉     ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 22 \(.*\)\$@\1 ⠈⠂    ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 23 \(.*\)\$@\1  ⠢    ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 24 \(.*\)\$@\1  ⠠⠄   ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 25 \(.*\)\$@\1   ⠔   ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 26 \(.*\)\$@\1   ⠐⠁  ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 27 \(.*\)\$@\1    ⠉  ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 28 \(.*\)\$@\1    ⠈⠂ ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 29 \(.*\)\$@\1     ⠢ ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+ [0-9]\+\) 30 \(.*\)\$@\1     ⠠ ${navy_white}\2@; t endpattern;
              s@^\([ ]*[0-9:.]\+\) [0-9]\+ 3[123] \(.*\)\$@\1       \2@; t endcolor;
 :endpattern; s@^\([ ]*[0-9:.]\+ \)0 \(.*\)\$@\1${navy_rb196}\2@; t endcolor;
              s@^\([ ]*[0-9:.]\+ \)1 \(.*\)\$@\1${navy_rb202}\2@; t endcolor;
              s@^\([ ]*[0-9:.]\+ \)2 \(.*\)\$@\1${navy_rb208}\2@; t endcolor;
              s@^\([ ]*[0-9:.]\+ \)3 \(.*\)\$@\1${navy_rb214}\2@; t endcolor;
              s@^\([ ]*[0-9:.]\+ \)4 \(.*\)\$@\1${navy_rb220}\2@; t endcolor;
              s@^\([ ]*[0-9:.]\+ \)5 \(.*\)\$@\1${navy_rb226}\2@; t endcolor;
              s@^\([ ]*[0-9:.]\+ \)6 \(.*\)\$@\1${navy_rb190}\2@; t endcolor;
              s@^\([ ]*[0-9:.]\+ \)7 \(.*\)\$@\1${navy_rb154}\2@; t endcolor;
              s@^\([ ]*[0-9:.]\+ \)8 \(.*\)\$@\1${navy_rb118}\2@; t endcolor;
              s@^\([ ]*[0-9:.]\+ \)9 \(.*\)\$@\1${navy_rb82}\2@; t endcolor;
              s@^\([ ]*[0-9:.]\+ \)10 \(.*\)\$@\1${navy_rb46}\2@; t endcolor;
              s@^\([ ]*[0-9:.]\+ \)11 \(.*\)\$@\1${navy_rb47}\2@; t endcolor;
              s@^\([ ]*[0-9:.]\+ \)12 \(.*\)\$@\1${navy_rb48}\2@; t endcolor;
              s@^\([ ]*[0-9:.]\+ \)13 \(.*\)\$@\1${navy_rb49}\2@; t endcolor;
              s@^\([ ]*[0-9:.]\+ \)14 \(.*\)\$@\1${navy_rb50}\2@; t endcolor;
              s@^\([ ]*[0-9:.]\+ \)15 \(.*\)\$@\1${navy_rb51}\2@; t endcolor;
              s@^\([ ]*[0-9:.]\+ \)16 \(.*\)\$@\1${navy_rb45}\2@; t endcolor;
              s@^\([ ]*[0-9:.]\+ \)17 \(.*\)\$@\1${navy_rb39}\2@; t endcolor;
              s@^\([ ]*[0-9:.]\+ \)18 \(.*\)\$@\1${navy_rb33}\2@; t endcolor;
              s@^\([ ]*[0-9:.]\+ \)19 \(.*\)\$@\1${navy_rb27}\2@; t endcolor;
              s@^\([ ]*[0-9:.]\+ \)20 \(.*\)\$@\1${navy_rb21}\2@; t endcolor;
              s@^\([ ]*[0-9:.]\+ \)21 \(.*\)\$@\1${navy_rb57}\2@; t endcolor;
              s@^\([ ]*[0-9:.]\+ \)22 \(.*\)\$@\1${navy_rb93}\2@; t endcolor;
              s@^\([ ]*[0-9:.]\+ \)23 \(.*\)\$@\1${navy_rb128}\2@; t endcolor;
              s@^\([ ]*[0-9:.]\+ \)24 \(.*\)\$@\1${navy_rb165}\2@; t endcolor;
              s@^\([ ]*[0-9:.]\+ \)25 \(.*\)\$@\1${navy_rb201}\2@; t endcolor;
              s@^\([ ]*[0-9:.]\+ \)26 \(.*\)\$@\1${navy_rb200}\2@; t endcolor;
              s@^\([ ]*[0-9:.]\+ \)27 \(.*\)\$@\1${navy_rb199}\2@; t endcolor;
              s@^\([ ]*[0-9:.]\+ \)28 \(.*\)\$@\1${navy_rb198}\2@; t endcolor;
              s@^\([ ]*[0-9:.]\+ \)29 \(.*\)\$@\1${navy_rb197}\2@;
   :endcolor; s@^@${navy_bold}${navy_white}@;s@\$@${navy_reset}${navy_sol}@"
    set +f
  fi
}

progress_bar ()
{
  :
  # ▏▎▍▌▋▊▉█
  # ▁▁▁▁▁▁▁▁
  # █████  ▕
  # ▔▔▔▔▔▔▔▔
  # ▁▁▁▁▁▁▁▁
  #▕█████   ▎
  # ▔▔▔▔▔▔▔▔
}

cols ()
{
  local tty
  tty="$(command readlink -f "${navy_tty}")"
  COLUMNS="$(command stty -F "${tty}" size | command cut -d ' ' -f 2)"
  COLUMNS="${COLUMNS:-"$(command tput cols)"}"
}

logs ()
{
  local entries date first_max_length_line max_line_length does_line_has_enought_chars

  entries="$(command find "${navy_lines}" -mindepth 1 -maxdepth 1 -type f | command sort -n -t '/' -k "${1}" | command head -n 300)"

  if [ -n "${entries:-}" ]
  then
    date="$(command date '+%T')"
    cols
    first_max_length_line="$(printf "%$(( ${COLUMNS} + ${#navy_bold} + ${#navy_cyan} + ${#navy_reset} ))s" | tr ' ' '.')"
    does_line_has_enought_chars="$(printf "%${COLUMNS}s" | sed 's/ /\[^\\n]/g')"
    max_line_length="$(printf "%${COLUMNS}s" | tr ' ' '.')"
    set -f
    # TODO: "\n${navy_sol}" * ((nb of term raws of the current logline) + (nb of spins))
    command sed          "s@^0@${navy_red}ERROR ${navy_reset}@;    t header;
                          s@^1@${navy_yellow} WARN ${navy_reset}@; t header;
                          s@^2@${navy_green} INFO ${navy_reset}@;  t header;
                          s@^3@${navy_cyan} NOTE ${navy_reset}@;   t header;
                          s@^4@${navy_blue}TRACE ${navy_reset}@;   t header;
                          s@^5@${navy_purple} VERB ${navy_reset}@;
                 :header; s@^@${date} ${navy_bold}@;  t reset_T_smaller;
        :reset_T_smaller; s@^${first_max_length_line}@&\n@;        T smaller; t loop;
                   :loop; s@\n\$@@;                                t equal;
                          h;
                          s@\(.\)\n.*@\1@;
                          p;
                          g;
                          s@.*\n@@;
                          s@^@               @;                    t reset_t_loop;
           :reset_t_loop; /${does_line_has_enought_chars}$/ {
                            s@^${max_line_length}@\0\n@;           t loop;
                          };
                  :equal;
                :smaller;
                   :exit;" ${entries}

    command rm -f ${entries}
    set +f
  fi
}

_stop ()
{
  local entries
  entries="$(command find "${navy_stops}" -mindepth 1 -maxdepth 1 -type l)"

  if [ -n "${entries:-}" ]
  then
    set -f
    command rm -f ${entries} $(command readlink -f ${entries})
    set +f
  fi
}

logger ()
{
  trap 'navy_loggerstart=1' USR1

  add_style

  local field_logs field_spins
  field_logs="$(printf '%s//\n' "${navy_lines}" | command grep -o '/' | command grep -c '/')"
  field_spins="$(printf '%s//\n' "${navy_spins}" | command grep -o '/' | command grep -c '/')"

  while [ -z "${navy_loggerstart:-}" ]; do command usleep 10; done

  trap 'navy_loggerstop=1' USR1

  printf '%b' "${navy_hidecursor}"

  while [ -z "${navy_loggerstop:-}" ] || command find "${navy_lines}" -mindepth 1 -maxdepth 1 -type f | read dummy
  do
    logs "${field_logs}" | spins "${field_spins}"
    if [ -z "${navy_loggerstop:-}" ]; then _stop; fi
  done

  printf '%b' "${navy_showcursor}"
}

add_time ()
{
  navy_s_per_min='60'
  navy_min_per_h='60'
  navy_s_per_h='3600'
  navy_ns_per_cs='10000000'
  navy_ns_per_ds='100000000'
  navy_ns_per_s='1000000000'
  navy_ns_per_10s='10000000000'
  navy_ns_per_min='60000000000'
  navy_ns_per_10min='600000000000'
  navy_ns_per_h='3600000000000'
  navy_ns_per_10h='36000000000000'
  navy_ns_per_100h='360000000000000'

  readonly navy_s_per_min navy_min_per_h navy_s_per_h navy_ns_per_cs navy_ns_per_ds navy_ns_per_s navy_ns_per_10s navy_ns_per_min navy_ns_per_10min navy_ns_per_h navy_ns_per_10h navy_ns_per_100h
}

listener ()
{
  add_time
  local line alias src i
  until [ -L "${navy_tty}" ] \
    && [ -d "${navy_lines}" ] \
    && [ -d "${navy_spins}" ] \
    && [ -d "${navy_aliases}" ] \
    && [ -d "${navy_stops}" ]; do command usleep 10; done
  while read -r line
  do
    i="$(( ${i:--1} + 1 ))"
    case "${line}" in
    ( K* ) command mv "${navy_aliases}/${line#K}" "${navy_stops}/${i}" ;;
    ( S* )
      line="${line#*/}"
      alias="${line%%/*}"
      line="${line#*/}"
      command date '+nts = %s%N' > "${navy_spins}/${i}"
      command cat << EOF >> "${navy_spins}/${i}"
scale = 0
nelapsed = (cnts - nts) % ${navy_ns_per_100h}
ns = nelapsed % ${navy_ns_per_s}
cs = ns / ${navy_ns_per_cs}
elapsed = (nelapsed - ns) / ${navy_ns_per_s}

define stop (nelapsed) {
  print (nelapsed / (5 * ${navy_ns_per_ds})) % 30, " ", (nelapsed / ${navy_ns_per_ds}) % 34, " ${line}\n"
  halt
}

if (nelapsed < ${navy_ns_per_10s}) print " ";
if (nelapsed < ${navy_ns_per_min}) {
  if (cs > 9) { print "   ", elapsed, ".", cs, " "; stop (nelapsed); }
  if (cs < 10) { print "   ", elapsed, ".0", cs, " "; stop (nelapsed); }
}
if (nelapsed >= ${navy_ns_per_min} && nelapsed < ${navy_ns_per_10min}) print " ";
if (nelapsed >= ${navy_ns_per_min} && nelapsed < ${navy_ns_per_h}) {
  sec = elapsed % ${navy_s_per_min}
  if (sec > 9) { print "   ", elapsed / ${navy_s_per_min}, ":", sec, " "; stop (nelapsed); }
  if (sec < 10) { print "   ", elapsed / ${navy_s_per_min}, ":0", sec, " "; stop (nelapsed); }
}n
if (nelapsed >= ${navy_ns_per_h} && nelapsed < ${navy_ns_per_10h}) print " ";
if (nelapsed >= ${navy_ns_per_h}) {
  sec = elapsed % ${navy_s_per_min}
  min = (elapsed / ${navy_s_per_min}) % ${navy_min_per_h}
  if (sec > 9 && min > 9) { print elapsed / ${navy_s_per_h}, ":", min, ":", sec, " "; stop (nelapsed); }
  if (sec < 10 && min > 9) { print elapsed / ${navy_s_per_h}, ":", min, ":0", sec, " "; stop (nelapsed); }
  if (sec > 9 && min < 10) { print elapsed / ${navy_s_per_h}, ":0", min, ":", sec, " "; stop (nelapsed); }
  if (sec < 10 && min < 10) { print elapsed / ${navy_s_per_h}, ":0", min, ":0", sec, " "; stop (nelapsed); }
}
EOF
      command ln -s "${navy_spins}/${i}" "${navy_aliases}/${alias}" ;;
    ( [012345]* ) printf '%s\n' "${line}" > "${navy_lines}/${i}" ;;
    ( * ) printf '%s%s\n' "${PS4}" "${line}" > "${navy_lines}/${i}" ;;
    esac
  done
}

send_error () { if [ "${navy_loglevel}" -ge '0' ]; then ansi2txt | sed 's@^@0@' >&3; fi; }
send_warn () { if [ "${navy_loglevel}" -ge '1' ]; then ansi2txt | sed 's@^@1@' >&3; fi; }
send_info () { if [ "${navy_loglevel}" -ge '2' ]; then ansi2txt | sed 's@^@2@' >&3; fi; }
send_note () { if [ "${navy_loglevel}" -ge '3' ]; then ansi2txt | sed 's@^@3@' >&3; fi; }
send_verb () { if [ "${navy_loglevel}" -ge '5' ]; then ansi2txt | sed 's@^@5@' >&3; fi; }

start_spin () { sed "s@^@S/${1}/@" >&3; }
stop_spin () { printf 'K%s\n' "${1}" >&3; }

help_option ()
{
  printf "\
A Docker Engine orchestrator

Usage:
  navy [flags]

Flags:
  --file file           navy main file (default: ./navy.yaml)
  --reset-cache         resets the cache
  -v                    prints only ERROR messages
  -v -v                 prints ERROR and WARN messages
  -v -v -v              prints ERROR, WARN, and INFO messages (default)
  -v -v -v -v           prints ERROR, WARN, INFO and NOTE messages
  -v -v -v -v -v        prints ERROR, WARN, INFO, NOTE and TRACE messages
  -v -v -v -v -v -v     prints ERROR, WARN, INFO, NOTE, TRACE and VERB messages
  --help                help for navy
  --version             version for navy
"
  return 1
}

version_option ()
{
  printf 'navy 0.1.0\n'
  return 1
}

reset_cache_option ()
{
  navy_resetcache='true'
}

file_option ()
{
  if [ ! -e "${1}" ]
  then
    printf '%s does not exist\n' "${1}" | send_error
    exit 1
  elif [ ! -r "${1}" ]
  then
    printf 'You do not have the permission to read %s\n' "${1}" | send_error
    exit 1
  fi
  navy_file="${1}"
}

v_option ()
{
  navy_loglevel="$(( ${navy_loglevel:--1} + 1 ))"
}

unknown_option ()
{
  printf 'Unknown option: %s\n' "'${1}'" | send_error
  return 1
}

parse_options ()
{
  while [ "${#}" != '0' ]
  do
    case "${1}" in

    # Handle '-abc' the same as '-a -bc' for short-form no-arg options
    ( -[v]?* )
      IFS=' '
      set -f
      set -- "${1%"${1#??}"}" "-${1#??}" $(shift; printf '%s\n' "${@}")
      set +f
      IFS="${navy_ifs}"
      continue ;;

    # Handle '--file=file1' the same as '--file file1' for long-form 1-arg options
    ( --file=* )
      IFS=' '
      set -f
      set -- "${1%%=*}" "${1#*=}" $(shift; printf '%s\n' "${@}")
      set +f
      IFS="${navy_ifs}"
      continue ;;

    ( --reset-cache ) reset_cache_option ;;
    ( --file ) file_option "${2}"; shift ;;
    ( -v ) v_option ;;
    ( --help ) help_option ;;
    ( --version ) version_option ;;
    ( * ) unknown_option "${1}" ;;
    esac
    shift
  done
}

prepare_curl ()
{
  navy_reqheader='http:/'
  navy_curlresp="${NAVY_RUN_PATH}/curlresponse.json"
  navy_curlopts="${navy_curlopts:+"${navy_curlopts:-}" }--silent --write-out %{http_code} --output ${navy_curlresp}"

  if [ -z "${DOCKER_HOST:-}" ]
  then
    navy_curlopts="${navy_curlopts:+"${navy_curlopts}" }--unix-socket /var/run/docker.sock"
  else
    navy_reqheader="${navy_reqheader}/${DOCKER_HOST#*://}"
  fi

  readonly navy_reqheader navy_curlresp navy_curlopts
}

verbose_eval ()
{
  eval "${1} () { { set +x; } 2> /dev/null; if ! command ${1} ${opts:+"${opts}" }\"\${@}\"${pipe:+ 2>&1 | "${pipe}"}; then return 1; fi; set -x; }"
}

prepare_logging ()
{
  if [ "${navy_loglevel}" -gt 3 ]; then set -x; fi

  if [ "${navy_loglevel}" -gt 2 ]
  then
    navy_curlopts="--verbose --stderr ${navy_buffer}"
  fi

  local yqopts gomplateopts utilsopt findopts
  yqopts='--no-colors'
  if [ "${navy_loglevel}" -gt 4 ]
  then
    gomplateopts="${gomplateopts:+"${gomplateopts}" }--verbose"
    yqopts="${yqopts:+"${yqopts}" }--verbose"
    utilsopt='-v'
    findopts='-D exec -D search'
  fi

  if [ "${navy_loglevel}" -gt 3 ]
  then
    opts="${utilsopt:-}" pipe='send_verb' verbose_eval 'mkdir'
    opts="${utilsopt:-}" pipe='send_verb' verbose_eval 'mv'
    opts="${utilsopt:-}" pipe='send_verb' verbose_eval 'rm'
    opts="${findopts:-}" pipe='send_verb' verbose_eval 'find'
    opts="${gomplateopts:-}" verbose_eval 'gomplate'
    opts="${yqopts:-}" verbose_eval 'yq'
  else
    eval "gomplate () { command gomplate ${gomplateopts:+"${gomplateopts}" }\"\${@}\"; };
          yq () { command yq ${yqopts:+"${yqopts}" }\"\${@}\"; }"
  fi
}

prepare ()
{
  navy_file="${navy_file:-./navy.yaml}"
  navy_loglevel="${navy_loglevel:-2}"

  readonly navy_resetcache navy_file navy_loglevel

  prepare_logging
  prepare_curl
}

_curl ()
{
  rm -f "${navy_buffer}"

  local out
  if ! out="$(set -f; curl ${navy_curlopts} "${@}" "${req}")"
  then
    printf '%s HTTP response: %s\n' "'${req}'" "${out}" | send_error
    cat "${navy_buffer}" | send_error
    return 1
  fi

  if [ "${out%"${out#?}"}" != '2' ]
  then printf '%s HTTP response: %s\n' "'${req}'" "${out}" | send_warn; fi

  if [ -s "${navy_buffer}" ]
  then
    printf '[CURL] HTTP exchange between Navy and Docker Engine:\n' | send_note
    cat "${navy_buffer}" | send_note
    printf '[CURL] JSON response from Docker Engine:\n' | send_note
    command yq --no-colors --input-format 'json' --output-format 'json' "${navy_curlresp}" | send_note
  fi
}

_yq ()
{
  rm -f "${navy_buffer}"

  if ! yq "${@}" 2> "${navy_buffer}"
  then
    printf 'The YAML parser failed with this error:\n' | send_error
    cat "${navy_buffer}" | send_error
    return 1
  elif [ "${navy_loglevel}" -le 3 ] && [ -s "${navy_buffer}" ]
  then
    printf 'The YAML parser succeed but returns this warning:\n' | send_warn
    cat "${navy_buffer}" | send_warn
  elif [ -s "${navy_buffer}" ]
  then cat "${navy_buffer}" | send_verb; fi
}

_gom ()
{
  rm -f "${navy_buffer}"

  if ! gomplate "${@}" 2> "${navy_buffer}"
  then
    printf 'The Go Template processor failed with this error:\n' | send_error
    command yq --no-colors --input-format 'json' --output-format 'json' "${navy_buffer}" | send_error
    return 1
  elif [ "${navy_loglevel}" -le 3 ] && [ -s "${navy_buffer}" ]
  then
    printf 'The Go Template processor succeed but returns this warning:\n' | send_warn
    command yq --no-colors --input-format 'json' --output-format 'json' "${navy_buffer}" | send_warn
  elif [ -s "${navy_buffer}" ]
  then command yq --no-colors --input-format 'json' --output-format 'json' "${navy_buffer}" | send_verb; fi
}

request ()
{
  printf '%s/v%s%s\n' "${navy_reqheader}" "${navy_apiversion:-1.25}" "${1}"
}

get ()
{
  req="$(request "${req}")" _curl --request GET "${@}"
}

explode_main_file ()
{
  navy_exploded="${navy_cache}/navy.yaml"
  readonly navy_exploded
  _yq 'explode(.)' "${navy_file}" > "${navy_exploded}"
}

define_context_datasources ()
{
  local context version_json info_json
  context="${navy_cache}/context"
  version_json="${context}/version.json"
  info_json="${context}/info.json"

  mkdir -p "${context}"

  req='/version' get
  mv -f "${navy_curlresp}" "${version_json}"

  navy_apiversion="$(_gom --datasource "version=${version_json}" --in '{{ (datasource "version").ApiVersion }}')"
  req='/version' get
  mv -f "${navy_curlresp}" "${version_json}"

  req='/info' get
  mv -f "${navy_curlresp}" "${info_json}"
}

expand_datasources_into_datasources ()
{
  local datasources header ds escaped_ds
  datasources="${navy_cache}/datasources"

  mkdir -p "${datasources}"

  header="$(_yq '.datasources[] | "{{ $" + .id + " := (datasource \"" + .source + "\") }}"' "${navy_exploded}" | tr -d '\n')"

  # TODO: avoid shell loops
  for ds in $(_yq '.datasources[].source' "${navy_exploded}")
  do
    mkdir -p "${datasources}/$(dirname -- "${ds}")"
    escaped_ds="$(_yq '(explode(.) | .. | key = "{{ print \"" + key + "\" }}") |= .' "${ds}")"
    printf '%s%s\n' "${header}" "${escaped_ds}" | _gom $(_yq '.datasources[] | "--datasource " + .source + "=" + .source + " "' "${navy_exploded}" | tr '\n' ' ') --out "${datasources}/${ds}"

    # TODO: resolve templates recursively
    # current CLI:
    # CWD="${PWD}" ./navy
  done
}

expand_datasources_into_main ()
{
  :
  # resolve datasources in main Navy file (not for Requests & Commands)
}

expand_anchors ()
{
  :
  # resolve 'anchors' keywords
  #   - explode anchors and aliases
}

check_linear_includes ()
{
  :
  # check circular dependencies between includes
}

expand_datasources_into_includes ()
{
  :
  # resolve datasources in included files (not for Requests & Commands)
}

expand_includes ()
{
  :
  # resolve 'includes' keywords
}

expand_extends ()
{
  :
  # change loop run and run[].loop into dictionnaries to:
  #   resolve 'extends' (replace them with anchors and aliases then use yq explode)
}

generate_sh ()
{
  :
  # yq script to generate sh script.
}

init ()
{
  set -eu

  navy_ifs="${IFS}"
  navy_nl='
'
  NAVY_CACHE_PATH="${NAVY_CACHE_PATH:-/var/cache/navy}"
  NAVY_RUN_PATH="${NAVY_RUN_PATH:-/var/run/navy}"
  navy_sha="$(find . -type f -exec sha256sum {} \; | sha256sum)"
  navy_sha="${navy_sha%% *}"
  navy_cache="${NAVY_CACHE_PATH}/${navy_sha}"
  navy_logs="${NAVY_RUN_PATH}/logs"
  navy_lines="${navy_logs}/lines"
  navy_spins="${NAVY_RUN_PATH}/spins"
  navy_stops="${NAVY_RUN_PATH}/stops"
  navy_aliases="${NAVY_RUN_PATH}/aliases"
  navy_tty="${NAVY_RUN_PATH}/tty"
  navy_buffer="${NAVY_RUN_PATH}/buffer"
  navy_done="${NAVY_RUN_PATH}/done"
  readonly NAVY_CACHE_PATH NAVY_RUN_PATH navy_sha navy_cache navy_logs navy_lines navy_spins navy_stops navy_aliases navy_tty navy_buffer navy_done navy_ifs navy_nl

  PS4='4'

  mkdir -p "${NAVY_CACHE_PATH}" "${NAVY_RUN_PATH}"
}

not_cached ()
{
  if [ "${navy_resetcache:-}" = 'true' ] || [ ! -e "${navy_done}" ]; then return 0; else return 1; fi
}

init_processor ()
{
  exec 3>&2
  rm -r -f "${NAVY_RUN_PATH}/"*
  mkdir -p "${navy_cache}" "${navy_logs}" "${navy_lines}" "${navy_spins}" "${navy_stops}" "${navy_aliases}"
  ln -s "$(tty)" "${navy_tty}"
  kill -s USR1 "${navy_loggerpid}"
}

processor ()
{
  init_processor
  parse_options "${@}"
  prepare

  if not_cached
  then
    printf 'Prepare cache\n' | start_spin 'cache'
    explode_main_file
    define_context_datasources
    expand_datasources_into_datasources
    expand_datasources_into_main
    expand_anchors
    check_linear_includes
    expand_datasources_into_includes
    expand_includes
    expand_extends
    generate_sh
    stop_spin 'cache'
  fi

  # depending of parsed options:
  # - run sh script with: seq 1 10 | xargs --max-args 1 --max-procs "$(( $(nproc) + 1 ))" ./script
  # - or use git to see dependencies as a tree
}

main ()
{
  init
  logger &
  navy_loggerpid="${!}"
  readonly navy_loggerpid
  trap "kill -s USR1 ${navy_loggerpid}; wait" EXIT INT TERM
  { processor "${@}"; } 2>&1 | listener
}

main "${@}"

# ----------------------------------------------------------------------------
# MEMO
# ----------------------------------------------------------------------------
#
# regular:
# curl -s --unix-socket /var/run/docker.sock -X DELETE http://v1.45/containers/hardcore_jang?force=true
#
# filters/urlencode:
# curl -s --unix-socket /var/run/docker.sock 'http://1.45/images/json' -X GET -G --data-urlencode 'filters={"reference":{"172.17.2.3:5000/mywhalefleet/tiawl.local.*":true}}'
#
# attach: curl -s -N -T - -X POST --unix-socket ./docker.sock 'http://1.45/containers/aaebdff75c380b80556b9c2ce65b2c62ba4cdd59427d3f269d5a61d7b8a087b0/attach?stdout=1&stdin=1&stderr=1&stream=1' -H 'Upgrade: tcp' -H 'Connection: Upgrade'
#
# build:
# tar c -f context.tar -C /tmp .
# curl -s --data-binary @- --header 'Content-Type: application/x-tar' --no-buffer --unix-socket /var/run/docker.sock -X POST http://v1.45/build?dockerfile=Dockerfile&t=reg/proj/my-img:my-tag < context.tar
